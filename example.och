import "std.och"

# expressions defining new stack operations
expr swpovr(a b) = b a b
expr ovr2(a b) = a b a b

# generics + types + members
type Node<T> =
  next: ^Node<T>
  data: T

type LinkedList<T> =
  size: Int
  head: Node<T>
fn LinkedList.init = 0 self <-size

# generic functions + cast
fn NULL<T>[^T] = 0 cast(^T)
fn NULL2<T U>[^T ^U] =
  0 cast(^T)
  0 cast(^U)

# conditions
fn fizzbuzz(Int) =
  case
  (dup 15 % 0 eq?) pop "FizzBuzz\n" print
  (dup 3 % 0 eq?)  pop "Fizz\n" print
  (dup 5 % 0 eq?)  pop "Buzz\n" print
  else dump end

fn fib(Int) [Int] =
  case (dup 1 >)
    dup 1 - fib
    swp 2 - fib +
  end

# passing functions as arguments
fn test(Int) [Int] = 12 +
fn caller( Function(Int)[Int] ) [Int] =
  12 swp callfn

# const values
const IDK = 10 2 *

# see structs.och for a more detailed look into structs, reading pointers and members
fn main =
  new(LinkedList<Int>)
  dup ->size dump
  delete

  pushfn(test) caller dump

  # syntax allows for crazy shit
  # should stop at five
  0 while (dup case (dup 2 % 0 eq?) 10 else 5; <)
    dup dump 1 +
  end pop
